# ì•Œê³ ë¦¬ì¦˜

> ì•Œê³ ë¦¬ì¦˜ì€ ë¬´ì¡°ê±´ ë§ì´ í’€ì–´ë³´ê³  ë‹¤ì–‘í•œ ìœ í˜•ë“¤ì„ ìˆ™ì§€í•˜ê³  ìˆëŠ”ê²ƒì´ ìµœê³ ì˜ ë°©ë²•!
>
> ì½”ë”©í…ŒìŠ¤íŠ¸ëŠ” ì–´ë ¤ìš´ ë¬¸ì œëŠ” ì—†ì§€ë§Œ ë‚´ê°€ ë‹¤ì–‘í•œ ê°ë„ì—ì„œ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•ì„ ê°–ê³  ìˆëŠ”ì§€ íŒë‹¨í•˜ëŠ” ì²™ë„
>
> > ### íŒŒì´ì¬ ì½”ë”©í…ŒìŠ¤íŠ¸
> >
> > ëŒ€ì²´ë¡œ ì½”í…Œì—ì„œ 128~512MBë¡œ ë©”ëª¨ë¦¬ë¥¼ ì œí•œí•˜ëŠ”ë° íŒŒì´ì¬ì—ì„œëŠ” ë©”ëª¨ë¦¬ì œí•œì´ ê±¸ë¦¬ê¸° ì‰½ë‹¤.
> >
> > | ë°ì´í„° ê°œìˆ˜ | ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ |
> > | ----------- | ------------- |
> > | 1,000       | ì•½ 4KB        |
> > | 1,000,000   | ì•½ 4MB        |
> > | 10,000,000  | ì•½ 40MB       |
> >
> > ë¦¬ìŠ¤íŠ¸í¬ê¸°ê°€ 1,000ë§Œ ì´ìƒì¸ ê²½ìš° ë©”ëª¨ë¦¬ì œí•œ ì´ìŠˆê°€ ë°œìƒí™œ í™•ë¥ ì´ ë†’ìœ¼ë‹ˆ ê¼­ ê³ ë ¤í•˜ì



## ê·¸ë¦¬ë”” (íƒìš•ì•Œê³ ë¦¬ì¦˜)

### ğŸ’¡ í˜„ì¬ ìƒí™©ì—ì„œ ì§€ê¸ˆ ë‹¹ì¥ ì¢‹ì€ ê²ƒë§Œ ê³ ë¥´ëŠ” ë°©ë²•. í˜„ì¬ ì„ íƒì´ ë‚˜ì¤‘ì— ë¯¸ì¹ ì˜í–¥ì€ ê³ ë ¤í•˜ì§€ ì•ŠëŠ”ë‹¤.

> ì¼ë°˜ì ìœ¼ë¡œ ì•”ê¸°ê°€ í•„ìš”ì—†ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ì§€ë§Œ ë‚˜ì•„ê°€ì„œ `í”Œë¡œì´ë“œ ì›Œì…œ`, `ë‹¤ìµìŠ¤íŠ¸ë¼`, 'í¬ë£¨ìŠ¤ì¹¼' ë“± íŠ¹ì • ì•Œê³ ë¦¬ì¦˜ì„ ë¯¸ë¦¬ ì•Œê³ ìˆì–´ì•¼ í’€ ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜ë„ ìˆìŒ. ë”°ë¼ì„œ ë§ì€ ë¬¸ì œë¥¼ í’€ì–´ë³´ëŠ” ê²ƒì´ ê°€ì¥ ì¤‘ìš”.
>
> í•´ë‹¹ ë¬¸ì œë¥¼ í’€ê¸°ìœ„í•œ ìµœì†Œí•œì˜ ì•„ì´ë””ì–´ë¥¼ ë– ì˜¬ë ¤ ë°˜ë³µì ìœ¼ë¡œ ë‹¹ì¥ ì¢‹ì€ê²ƒì„ ê³ ë¥´ëŠ” ë°©ë²•ì¸ì§€ ê²€í† í•´ì•¼í•¨.



## êµ¬í˜„

### ğŸ’¡í˜„ì¬ ë¨¸ë¦¿ì†ì— ìˆëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ì†ŒìŠ¤ì½”ë“œë¡œ ë°”ê¾¸ëŠ” ê³¼ì •. ë¬¸ë²•ìˆ™ì§€ í•„ìˆ˜!  ë‹¤ì–‘í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê²½í—˜ì´ ìˆìœ¼ë©´ ë” ì¢‹ë‹¤!

> í’€ì´ë¥¼ ë– ì˜¬ë¦¬ëŠ” ê²ƒì€ ì‰½ì§€ë§Œ ì½”ë“œë¡œ ì˜®ê¸°ëŠ” ê²ƒì´ ì–´ë ¤ìš´ ë¬¸ì œ. ë³´í†µ ì‚¬ì†Œí•œ ì…ë ¥ ì¡°ê±´ë“±ì„ ëª…ì‹œí•´ ì£¼ê³  ë¬¸ì œì˜ ê¸¸ì´ê°€ ê¸´ í¸.
>
>  #### ì™„ì „íƒìƒ‰: ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ë‹¤ ê³„ì‚°í•˜ëŠ” ë°©ë²•
>
>  #### ì‹œë®¬ë ˆì´ì…˜: ë¬¸ì œì—ì„œ ì œì‹œí•œ ì•Œê³ ë¦¬ì¦˜ì„ í•œ ë‹¨ê³„ì”© ì°¨ë¡€ëŒ€ë¡œ ì§ì ‘ ìˆ˜í–‰í•˜ëŠ” ë¬¸ì œ
>
> 2ì°¨ì› ë°°ì—´ì—ì„œ ë°©í–¥ë²¡í„°ë¥¼ ì‚¬ìš©í•˜ëŠ” ë¬¸ì œê°€ ìì£¼ ì¶œì œë¨



## DFS & BFS

### ğŸ’¡ê·¸ë˜í”„ë¥¼ íƒìƒ‰í•˜ê¸°ìœ„í•œ ëŒ€í‘œì ì¸ ë‘ ì•Œê³ ë¦¬ì¦˜

> #### ìë£Œêµ¬ì¡°
>
> ë°ì´í„°ë¥¼ í‘œí˜„í•˜ê³  ê´€ë¦¬í•˜ê³  ì²˜ë¦¬í•˜ê¸° ìœ„í•œ êµ¬ì¡°. DFS BFS ì•Œê³ ë¦¬ì¦˜ì„ ìœ„í•´ ì„¤ëª…ì´ í•„ìš”í•œ ë‘ê°€ì§€ì˜ ìë£Œêµ¬ì¡° **stack** ê³¼ **í**
>
> > #### stack
> >
> > í”íˆ ë°•ìŠ¤ìŒ“ê¸°ë¡œ ë¹„ìœ . ì•„ë˜ì—ì„œ ë¶€í„° ìœ„ë¡œ ìŒ“ê³ , ì¹˜ìš¸ ë•ŒëŠ” ìœ„ì—ì„œë¶€í„° ì¹˜ìš´ë‹¤.
> >
> > **ì„ ì…í›„ì¶œ(First In Last Out) ë˜ëŠ” í›„ì…ì„ ì¶œ(Last In First Out)**
> >
> > **ex**
> >
> > ì‚½ì…(5) ì‚½ì…(2) ì‚½ì…(3) ì‚½ì…(7) ì‚­ì œ() ì‚½ì…(1) ì‚½ì…(4) ì‚­ì œ() ....
> >
> > 5  2  3  (7)  1  (4)
> >
> > ìµœì¢… ë‚¨ì€ stack 5231
>
> > #### queue
> >
> > ëŒ€ê¸°ì¤„ë¡œ ë¹„ìœ . ë¨¼ì € ë“¤ì–´ì˜¨ ê²ƒì´ ë¨¼ì € ë‚˜ê°„ë‹¤.
> >
> > 1 2 3 4 5 ìˆœìœ¼ë¡œ ë“¤ì–´ì™”ë‹¤ë©´ í˜¸ì¶œë„ 1 2 3 4 5
>
> 
>
> > **í ì˜ˆì œ: ì‚½ì…(5) ì‚½ì…(2) ì‚½ì…(3) ì‚½ì…(7) ì‚­ì œ() ì‚½ì…(1) ì‚½ì…(4) ì‚­ì œ()**
> >
> > ``` python
> > from collection import deque
> > 
> > queue = deque()
> > 
> > queue.append(5)
> > queue.append(2)
> > queue.append(3)
> > queue.append(7)
> > queue.popleft()
> > queue.append(1)
> > queue.append(4)
> > queue.popleft()
> > 
> > print(queue)  # 5 2 3 1
> > queue.reverse()	 # ì—­ìˆœìœ¼ë¡œ ë°”ê¿ˆ
> > print(queue)  # 1 3 2 5
> > ```
> >
> > `queue` ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” `list`ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ ë³´ë‹¤ ì—°ì‚°ì†ë„ê°€ ë¹¨ë¼ ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ ìœ ë¦¬í•˜ë‹¤! `collection` ëª¨ë“ˆì€ ëŒ€ë¶€ë¶„ ì½”í…Œì—ì„œë„ ì±„íƒí•´ì„œ ì•ˆì‹¬í•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤



### DFS

> ê¹Šì´ ìš°ì„  íƒìƒ‰(Depth-First-Search)ë¼ê³  ë¶€ë¥´ë©°, ê·¸ë˜í”„ì—ì„œ ê¹Šì€ ë¶€ë¶„ì„ ìš°ì„ ì ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
>
> 1. íƒìƒ‰ ì‹œì‘ ë…¸ë“œë¥¼ ìŠ¤íƒì— ì‚½ì…í•˜ê³  ë°©ë¬¸ì²˜ë¦¬
> 2. ìŠ¤íƒì˜ ìµœì‚¬ë‹¨ ë…¸ë“œì— ì¸ì ‘í•˜ê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œê°€ ìˆìœ¼ë©´ ì¸ì ‘ë…¸ë“œë¥¼ ìŠ¤íƒì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬. ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ë…¸ë“œê°€ ì—†ìœ¼ë©´ ìŠ¤íƒ ìµœìƒë‹¨ ë…¸ë“œë¥¼ êº¼ëƒ„
> 3. 2ë²ˆ ê³¼ì •ì„ ë” ì´ìƒ ìˆ˜í–‰í•  ìˆ˜ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ
>
> ì£¼ë¡œ ì¬ê·€í•¨ìˆ˜`recursive function` ì´ìš©
>
> #### ê·¸ë˜í”„
>
> ê·¸ë˜í”„ëŠ” ë…¸íŠ¸`Node`ì™€ ê°„ì„ `Edge`ë¡œ í‘œí˜„ë˜ë©° ë…¸ë“œëŠ” ì •ì `Vertex`ë¡œ ë¶ˆë¦¬ê¸°ë„ í•œë‹¤.
>
> ê·¸ë˜í”„ëŠ” í¬ê²Œ ë‘ê°€ì§€ ë°©ì‹ìœ¼ë¡œ í‘œí˜„
>
> - ì¸ì ‘ í–‰ë ¬(Adjanceney Matrix): 2ì°¨ì› ë°°ì—´ë¡œ ê·¸ë˜í”„ ì—°ê²°ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë°©ì‹. ì—°ê²°ë˜ì§€ ì•Šì€ ê³³ì€ 0 ë˜ëŠ” ë¬´í•œ ë¹„ìš©ìœ¼ë¡œ ì²˜ë¦¬
>
>   ``` python
>   INF = 9999999 # ë¬´í•œë¹„ìš©
>   
>   graph = [
>       [0, 7, 5],
>       [7, 0, INF],
>       [5, INF, 0]
>   ]
>   ```
>
>   ì´ ê·¸ë˜í”„ëŠ” 0ë²ˆ ì •ì ì´ 1, 2ë²ˆ ë…¸ë“œì— ê°ê° 7, 5 ë¹„ìš©ìœ¼ë¡œ ì—°ê²°
>
>   1ë²ˆ ì •ì ì´ 0ë²ˆì— ë§Œ ì—°ê²°, 2ë²ˆ ì •ì ì´ 0ë²ˆì—ë§Œ ì—°ê²°ë˜ì–´ ìˆìŒ.
>
> - ì¸ì ‘ ë¦¬ìŠ¤íŠ¸(Adjanceney List): ë¦¬ìŠ¤íŠ¸ë¡œ ê·¸ë˜í”„ì˜ ì—°ê²°ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë°©ì‹
>
>   > ```python
>   > graph = [[(1,7),(2,5)], [(0,7)], [(0,5)]
>   > ```
>   >
>   > ì¸ì ‘ í–‰ë ¬ê³¼ ê°™ì€ ì—°ê²°ìƒíƒœë¥¼ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„í•¨
>
> #### DFS method
>
> ``` python
> def DFS(graph, v, visited):
>     visited[v] = 1
>     for i in graph[v]:
>         if not visited[i]:
>             DFS(graph, i, visited)
> ```



### BFS

> ë„ˆë¹„ ìš°ì„  íƒìƒ‰(Breadth-First-Search) ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜. ì£¼ë¡œ `queue` ì´ìš©
>
> 1. íƒìƒ‰ ì‹œì‘ ë…¸ë“œë¥¼ íì— ì‚½ì…í•˜ê³  ë°©ë¬¸ì²˜ë¦¬
> 2. íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ ì¸ì ‘ ë…¸ë“œì¤‘ì— ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë¥¼ ëª¨ë‘ íì— ì‚½ì…
> 3. 2ë²ˆ ê³¼ì •ì„ ë” ì´ìƒ ìˆ˜í–‰í•  ìˆ˜ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ
>
> #### BFS method
>
> ``` python
> from collection import deque
> 
> def BFS(graph, start, visited):
>     queue = deque([start])
>     visited[start] = 1
>     
>     while queue:
>         v = queue.popleft()
>         for i in graph[v]:
>             if not visited[i]:
>                 queue.append(i)
>                 visited[i] = 1
> ```



## ì •ë ¬

### ğŸ’¡ ë°ì´í„°ë¥¼ íŠ¹ì •í•œ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ì—´í•˜ëŠ” ê²ƒ

#### ex) 7 5 9 0 3 1 6 2 4 8 ê° ìˆ«ìê°€ ì íŒ ì¹´ë“œë¥¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

1. ì„ íƒì •ë ¬

   > ì´ì¤‘ ê°€ì¥ ì‘ì€ ë°ì´í„°ë¥¼ ì°¾ì•„ ë§¨ ì•ì— ë°ì´í„°ì™€ ë°”ê¾¸ê³ , ë§¨ ì• ë°ì´í„°ë¥¼ ì œì™¸í•œ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì• ê³¼ì •ì„ ë°˜ë³µ. ê°€ì¥ ì›ì‹œì ì¸ ë°©ë²•(ë‹¤ì†Œ ëŠë¦¼)
   >
   > ```  python
   > array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
   > 
   > for i in range(len(array)):
   >     min_index = i
   >     for j in range(i+1, len(array)):
   >         if array[j] < array[min_index]:
   >             min_index = j
   >     array[i],array[min_index] = array[min_index],array[i]
   > ```
   >
   > **ì„ íƒì •ë ¬ì˜ ì‹œê°„ë³µì¡ë„**
   >
   > `N-1`ë²ˆ ë§Œí¼ ê°€ì¥ ì‘ì€ìˆ˜ë¥¼ ì°¾ì•„ì„œ ë§¨ ì•ìœ¼ë¡œ ë³´ë‚´ì•¼í•œë‹¤. ë”°ë¼ì„œ `N + (N-1) + (N-2) + ... + 2` ì‹ì´ ì™„ì„±ë˜ê³  ì¤„ì—¬ì„œ `N(N + 1) / 2` ê°’ì´ ë‚˜ì˜¨ë‹¤.
   >
   > ì‹œê°„ë³µì¡ë„ëŠ” ê°€ì¥ ë†’ì€ì°¨ìˆ˜ë§Œì„ íŒë‹¨í•˜ê¸°ì— **O(N^2)**ì´ë‹¤.

2. ì‚½ì…ì •ë ¬

   > ì„ íƒì •ë ¬ë³´ë‹¤ êµ¬í˜„ ë‚œì´ë„ëŠ” ì–´ë µì§€ë§Œ ì‹œê°„ ì¸¡ë©´ì—ì„œ íš¨ìœ¨ì ì„. ë°ì´í„°ë¥¼ í•˜ë‚˜ì”© í™•ì¸í•˜ë©° ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì…í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜. íŠ¹ì • ë°ì´í„°ê°€ ì ì ˆí•œ ìœ„ì¹˜ì— ë“¤ì–´ê°€ê¸° ì´ì „ì—, ê·¸ ì•ê¹Œì§€ì˜ ë°ì´í„°ëŠ” ì´ë¯¸ ì •ë ¬ë˜ì–´ìˆë‹¤ê³  ê°€ì •í•œë‹¤.
   >
   > ``` python
   > array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
   > 
   > for i in range(1, len(array)):
   >     for j in range(i, 0, -1):
   >         if array[j] < array[j-1]:	# í•œì¹¸ì”© ì™¼ìª½ìœ¼ë¡œ ì›€ì§ì´ë©´ì„œ ìê¸°ë³´ë‹¤ í° ê°’ê³¼ëŠ” ìë¦¬ë°”ê¿ˆ
   >             array[j],array[j-1] = array[j-1], array[j]
   >         else:		# jë³´ë‹¤ ì‘ì€ê°’ì´ ì™¼ìª½ì— ìˆìœ¼ë©´ ë©ˆì¶¤
   >             break
   > ```
   >
   > **ì‚½ì…ì •ë ¬ì˜ ì‹œê°„ë³µì¡ë„**
   >
   > ì´ì¤‘ `for`ë¬¸ìœ¼ë¡œ ì„ íƒì •ë ¬ê³¼ ê°™ê²Œ **O(N^2)**ì´ë‹¤. ì‹¤ì œë¡œ ê³„ì‚°í•´ë³´ì•„ë„ ë‘ ì•Œê³ ë¦¬ì¦˜ì€ ë¹„ìŠ·í•œ ê°’ì´ ë‚˜ì˜´. í•˜ì§€ë§Œ ê±°ì˜ ì •ë ¬ë˜ì–´ ìˆëŠ”ìƒíƒœì—ì„œëŠ” ì‚½ì…ì •ë ¬ì€ í€µì •ë ¬ë³´ë‹¤ ë¹ ë¥¼ ì •ë„ë¡œ ì›”ë“±íˆ ë¹ ë¥¸ì†ë„ë¥¼ ë³´ì„.

3. í€µì •ë ¬

   > ê¸°ì¤€ ë°ì´í„°ë¥¼ ì •í•˜ê³  ê·¸ ê¸°ì¤€(í”¼ë²—`pivot`)ë³´ë‹¤ í° ë°ì´í„°ì™€ ì‘ì€ ë°ì´í„°ì˜ ìœ„ì¹˜ë¥¼ ë°”ê¾¼ë‹¤.
   >
   > > #### í”¼ë²— ì„¤ì •í•˜ëŠ” ë°©ë²•
   > >
   > > í˜¸ì–´ ë¶„í•­ ë°©ì‹ `Hoare Partition` (ëŒ€í‘œì ì¸ ë°©ë²•)
   > >
   > > 1. ë¦¬ìŠ¤íŠ¸ì—ì„œ ì²« ë²ˆì§¸ ë°ì´í„°ë¥¼ í”¼ë²—ìœ¼ë¡œ ì •í•œë‹¤.
   > > 2. ì™¼ìª½ì—ì„œ ë¶€í„° í”¼ë²—ë³´ë‹¤ í° ë°ì´í„°ë¥¼ ì°¾ê³ , ì˜¤ë¥¸ìª½ì—ì„œë¶€í„° í”¼ë²—ë³´ë‹¤ ì‘ì€ ë°ì´í„°ë¥¼ ì°¾ëŠ”ë‹¤.
   > > 3. í° ë°ì´í„°ì™€ ì‘ì€ ë°ì´í„°ì˜ ìœ„ì¹˜ë¥¼ êµí™˜í•´ì¤€ë‹¤.
   > > 4. ì• ê³¼ì •ì„ ê³„ì† ë°˜ë³µí•˜ë‹¤ê°€, ì™¼ìª½ì—ì„œ ì˜¨ ê°’ê³¼ ì˜¤ë¥¸ìª½ì—ì„œ ì˜¨ ê°’ì´ ì„œë¡œ ë¦¬ìŠ¤íŠ¸ë¥¼ êµì°¨í•  ë•Œ, í”¼ë²—ë³´ë‹¤ ì‘ì€ê°’ê³¼, í”¼ë²—ì˜ ìœ„ì¹˜ë¥¼ êµí™˜í•´ì¤€ë‹¤.
   > > 5. ì´ì œ í”¼ë²—ì„ ê¸°ì¤€ìœ¼ë¡œ ì•ì€ í”¼ë²—ë³´ë‹¤ ì‘ì€ê°’, ë’¤ëŠ” í”¼ë²—ë³´ë‹¤ í° ê°’ë“¤ë¡œ ë‚˜ë‰˜ì—ˆìœ¼ë‹ˆ, ê°œë³„ì ìœ¼ë¡œ 1ì—ì„œ 5ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•´ ì •ë ¬ì‹œí‚¨ë‹¤.
   > > 6. í”¼ë²—ì„ ì„¤ì •í•  ë¦¬ìŠ¤íŠ¸ì˜ ê¸¸ì´ê°€ 1ê°œê°€ ë˜ë©´ ê·¸ ë¦¬ìŠ¤íŠ¸ëŠ” ì¢…ë£Œ.
   >
   > 
   >
   > **ì§ê´€ì ì¸ í€µì •ë ¬ ì†ŒìŠ¤ì½”ë“œ**
   >
   > ``` python
   > array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
   > 
   > def quick_sort(array, start, end):
   >     if start >= end:
   >         return
   >     pivot = start	# pivotì€ ì‹œì‘ ì›ì†Œ
   >     left = start + 1
   >     right = end
   >     
   >     while left < right:		# ì™¼ìª½ ì˜¤ë¥¸ìª½ ê°’ì´ êµì°¨í•˜ë©´ ë°˜ë³µë¬¸ ì¤‘ì§€
   >         
   >         while left <= end and array[left] <=array[pivot]:		
   >             # leftê°€ ë ì¸ë±ìŠ¤ì— ê°€ì§€ ì•Šê³ , í”¼ë²—ë³´ë‹¤ ì‘ì€ê°’ì´ë©´ í° ê°’ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µ
   >             left += 1
   >         
   >         while right > start and array[right] >= array[pivot]:	
   >             # rightì´ ì²« ì¸ë±ìŠ¤ì— ê°€ì§€ ì•Šê³ , í”¼ë²—ë³´ë‹¤ í° ê°’ì´ë©´ ì‘ì€ ê°’ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µ
   >             right -= 1
   >         
   >         if left > right:
   >             # í° ê°’ ì¸ë±ìŠ¤ì™€ ì‘ì€ ê°’ ì¸ë±ìŠ¤ê°€ êµì°¨í–ˆìœ¼ë©´, ì‘ì€ ê°’ì„ í”¼ë²—ìœ¼ë¡œ ì„¤ì •
   >             array[right], array[pivot] = array[pivot], array[right]
   >         else:
   >             # ì—‡ê°ˆë¦¬ì§€ ì•Šì•˜ë‹¤ë©´ í° ê°’ ì‘ì€ ê°’ êµì²´
   >             array[right], array[left] = array[left], array[right]
   >         
   >         
   >     # ë¶„í• í•˜ì—¬ í€µì •ë ¬ ì‹¤í–‰
   >     quick_sort(array, start, right-1)
   >     quick_sort(array, right+1, end)
   >     
   > quick_sort(array, 0, len(array)-1)
   > ```
   >
   > 
   >
   > **íŒŒì´ì¬ ì¥ì ì„ ì‚´ë¦° í€µì •ë ¬ ì†ŒìŠ¤ì½”ë“œ**
   >
   > ```python
   > array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
   > 
   > def quick_sort(array):
   >     if len(array) <= 1:
   >         # ë°°ì—´ì´ 1ê°œ ì´í•˜ë©´ ì¢…ë£Œ
   >         return array
   >     
   >     pivot = array[0]	# ì²« ì¸ë±ìŠ¤ í”¼ë²—ì„¤ì •
   >     tail = array[1:]	# í”¼ë²—ì„ ì œì™¸í•œ ë¦¬ìŠ¤íŠ¸
   >     
   >     left_side = [x for x in tail if x <= pivot]		# pivotë³´ë‹¤ ì‘ì€ê°’ì„ ë‹´ì€ ì™¼ìª½ ë¶€ë¶„
   >     right_side = [x for x in tail if x > pivot]		# pivotë³´ë‹¤ í° ê°’ì„ ë‹´ì€ ì˜¤ë¥¸ìª½ ë¶€ë¶„
   >     
   >     # ë¶„í•  ì´í›„ ì™¼ìª½ ë¶€ë¶„ + í”¼ë²— + ì˜¤ë¥¸ìª½ ë¶€ë¶„ ì—ì„œ ê°ê° ì •ë ¬ì„ ìˆ˜í–‰í•˜ê³ , ì „ì²´ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
   >     return quick_sort(left_side) + [pivot] + quick_sort(right_side)
   > ```
   >
   > **í€µì •ë ¬ì˜ ì‹œê°„ë³µì¡ë„**
   >
   > **O(NlogN)**ìœ¼ë¡œ ì•ì„œ ë‹¤ë£¬ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ë“¤ì— ë¹„í•´ ì›”ë“±íˆ ë¹ ë¥¸ í¸ì´ë‹¤. ë¶„í• ì´ 1ë²ˆ ì¼ì–´ ë‚  ë•Œë§ˆë‹¤ 1/2 ì”© ê¸°í•˜ ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¤„ê¸°ì— ê°€ì¥ ë¹ ë¥¼ë•Œ(í•­ìƒ ì ˆë°˜ì”© ë‚˜ëˆ ì§ˆ ë•Œ)`logN`ì´ë‹¤.  ìµœì•…ì˜ ê²½ìš° `N^2` ê¹Œì§€ ê°ˆ ìˆ˜ ìˆì–´ í‰ê· ê°’ì€ `NlogN` ìœ¼ë¡œ ë‚˜íƒ€ë‚¸ë‹¤

4. ê³„ìˆ˜ì •ë ¬

   > íŠ¹ì •í•œ ì¡°ê±´ì´ ë¶€í•©í•  ë•Œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜.
   >
   > ë°ì´í„°ì˜ í¬ê¸° ë²”ìœ„ê°€ ì œí•œë˜ì–´ ì •ìˆ˜ í˜•íƒœë¡œ í‘œí˜„í•  ìˆ˜ ìˆì„ ë•Œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆê³ , ì¼ë°˜ì ìœ¼ë¡œ ìµœëŒ“ê°’ê³¼ ìµœì†Ÿê°’ì˜ ì°¨ì´ê°€ 1,000,000 ì´í•˜ì¼ ë•Œ íš¨ê³¼ì ì´ë‹¤.
   >
   > ë³„ë„ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì„ ì–¸í•˜ê³ , ì •ë ¬í•  ë¦¬ìŠ¤íŠ¸ë“¤ì˜ ê°’ì„ ì„ ì–¸í•œ ë¦¬ìŠ¤íŠ¸ì˜ ì¸ë±ìŠ¤ì— ìˆœì°¨ì ìœ¼ë¡œ ë„£ì–´ í•´ë‹¹ ë¦¬ìŠ¤íŠ¸ ê°’ì„ 1ì”© ì¦ê°€ì‹œí‚¨ë‹¤.
   >
   > ``` python
   > array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
   > 
   > count = [0]*(len(array)+1)
   > 
   > for i in range(len(array)):
   >  count[array[i]] += 1
   > 
   > for i in range(len(count)):
   >  for j in rnage(count[i]):
   >      print(i, end=' ')
   > ```
   >
   > **ê³„ìˆ˜ì •ë ¬ì˜ ì‹œê°„ë³µì¡ë„**
   >
   > ëª¨ë“  ë°ì´í„°ê°€ ì–‘ì˜ ì •ìˆ˜ì´ê³ , ìµœëŒ€ê°’ì´ Kì¼ ë•Œ, ìµœì•…ì˜ ê²½ìš°ì—ë„ ìˆ˜í–‰ì‹œê°„ì€ `O(N+K)`ë¥¼ ë³´ì¥í•œë‹¤. í•˜ì§€ë§Œ ë³„ë„ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ë¯€ë¡œ ê³µê°„ë³µì¡ë„ ì´ìŠˆê°€ ë°œìƒí•  ìˆ˜ ìˆìœ¼ë‹ˆ ë°ì´í„° ì–‘ì„ ì˜ ë³´ê³  íŒë‹¨í•´ì„œ ì‚¬ìš©í•´ì•¼í•œë‹¤.
   
5. íŒŒì´ì¬ì˜ ì •ë ¬ ë¼ì´ë¸ŒëŸ¬ë¦¬

   > - í•¨ìˆ˜ `sorted(array, (key))`: ì‹œê°„ë³µì¡ë„: `O(NlogN)`, í€µì •ë ¬ê³¼ ë¹„ìŠ·í•œ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ êµ¬ì„±ë¨
   >
   > - ë°°ì—´ ë©”ì„œë“œ `.sort((key))`: ë¦¬ìŠ¤íŠ¸ì— ë‚´ì¥ëœ ë©”ì„œë“œ. ë°˜í™˜ê°’ì´ ì—†ê³ , ë°°ì—´ìì²´ì ìœ¼ë¡œ ì •ë ¬í•¨.
   >
   >   ë‘ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª¨ë‘ `key`ê°’ì— ë§¤ê°œë³€ìˆ˜ë¥¼ ëŒ€ì…í•´ ë§¤ê°œë³€ìˆ˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ì‹œí‚¬ ìˆ˜ ìˆìŒ
   >
   >   **ex**
   >
   >   ``` python
   >   # 1
   >   array.sort(key=lambda x: x[1])
   >   # 2
   >   def setting(array):
   >   	return array[1]
   >             
   >   result = sorted(array, key=setting)
   >   ```



## ì´ì§„íƒìƒ‰

### ğŸ’¡ë°°ì°¾ìœ¼ë ¤ëŠ” ë°ì´í„°ì™€ ì¤‘ê°„ì  ìœ„ì¹˜ì— ìˆëŠ” ë°ì´í„°ë¥¼ ë°˜ë³µí•´ì„œ ë¹„êµí•´ì„œ íƒìƒ‰ (ê¸°ë³¸ì ìœ¼ë¡œ ë°°ì—´ì€ ì •ë ¬ë˜ì–´ìˆì–´ì•¼ í•¨)

**ì‹œê°„ë³µì¡ë„**: ì›ì†Œì˜ ê°œìˆ˜ê°€ ì ˆë°˜ì”© ì‚¬ë¼ì§€ë¯€ë¡œ `O(logN)`

> - ì¬ê·€í•¨ìˆ˜ë¡œ êµ¬í˜„í•œ ì†ŒìŠ¤ì½”ë“œ
>
>   ``` python
>   def binary_search(array, target, start, end):
>       if start > end:			# ì²« ì‹œì‘ì ê³¼ ëì ì´ êµì°¨ => ëª»ì°¾ì€ ê²ƒ
>           return None
>       mid = (start + end) // 2		# ì¤‘ê°„ì  ì¸ë±ìŠ¤ ë°˜í™˜
>               
>       if array[mid] == target:
>           return mid
>       elif array[mid] > target:
>           return binary_search(array, target, start, mid-1)
>       else:
>           return binary_search(array, target, mid+1, end)
>               
>   N, target = map(int, input().split())
>   # ë°°ì—´ ê¸¸ì´ì™€ íƒ€ê²Ÿë„˜ë²„
>           
>   array = list(map(int, input().split()))
>   # ë°°ì—´
>   result = binary_search(array, target, 0, N)
>   if result == None:
>       print(False)
>   else:
>       print(result)
>   ```
>
>   
>
>   - ë°˜ë³µë¬¸ìœ¼ë¡œ êµ¬í˜„í•œ ì†ŒìŠ¤ì½”ë“œ
>
>     ``` python
>     def binary_search(array, target, start, end):
>                         
>         while start <= end:
>             mid = (start + end) // 2		# ì¤‘ê°„ì  ì¸ë±ìŠ¤ ë°˜í™˜
>                             
>             if array[mid] == target:
>                 return mid
>             elif array[mid] > target:
>                 end = mid - 1
>             else:
>                 start = mid + 1
>                                 
>     	return None
>     ```
>
>   
>
>   ì´ì§„íƒìƒ‰ì€ ì‹œê°„ë³µì¡ë„ê°€ ì¢‹ì€ë§Œí¼ ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ì— ìì£¼ ì“°ì¸ë‹¤. ë˜í•œ ì½”ë”©í…ŒìŠ¤íŠ¸ì—ë„ ìì£¼ ë‚˜ì˜¤ëŠ” ì•Œê³ ë¦¬ì¦˜ ì´ê¸°ì— ë§Œì•½ ë§ì€ ì–‘ì˜ ì •ë ¬ëœ ë°ì´í„°ì—ì„œ íŠ¹ì •ê°’ì„ ì°¾ì•„ì•¼í•œë‹¤ë©´ ì´ì§„íƒìƒ‰ì„ ì‚¬ìš©í•˜ì

### íŠ¸ë¦¬ ìë£Œêµ¬ì¡°

> DBëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ì— ì í•©í•œ íŠ¸ë¦¬êµ¬ì¡°ë¥¼ í™œìš©í•˜ì—¬ í•­ìƒ ë°ì´í„°ê°€ ì •ë ¬ë˜ì–´ ìˆë‹¤. DBíƒìƒ‰ì€ ì´ì§„íƒìƒ‰ê³¼ ì¡°ê¸ˆ ë‹¤ë¥´ì§€ë§Œ, ìœ ì‚¬í•œ ë°©ë²•ì„ ì‚¬ìš©ë„ë¡ ì„¤ê³„ë˜ì–´ìˆë‹¤.
>
> #### íŠ¸ë¦¬
>
> íŠ¸ë¦¬ëŠ” ê·¸ë˜í”„ êµ¬ì¡°ì˜ ì¼ì¢…ì´ë©°, ë§ì€ ì–‘ì˜ ë°ì´í„°ë¥¼ ê´€ë¦¬í•˜ëŠ” ëª©ì ìœ¼ë¡œ ì“°ì´ëŠ” ìë£Œêµ¬ì¡°ë‹¤. ë…¸ë“œì™€ ë…¸ë“œì˜ ì—°ê²°ë¡œ ì´ë£¨ì–´ì ¸ìˆê³  ê° ë…¸ë“œëŠ” ì •ë³´ë“¤ì„ ê°–ê³ ìˆë‹¤.
>
> **íŠ¸ë¦¬ì˜ íŠ¹ì§•**
>
> 1. íŠ¸ë¦¬ ìµœìƒë‹¨ ë…¸ë“œë¥¼ ë£¨íŠ¸ë…¸ë“œë¼ê³  í•¨
> 2. ë…¸ë“œëŠ” ë¶€ëª¨ì™€ ìì‹ ê´€ê³„ë¡œ í‘œí˜„
> 3. íŠ¸ë¦¬ì—ì„œ ì¼ë¶€ë¥¼ ë–¼ì–´ë‚´ë„ íŠ¸ë¦¬êµ¬ì¡°ì´ë©° ì„œë¸ŒíŠ¸ë¦¬ë¼ê³  í•¨
>
> 
>
> > #### ì´ì§„íƒìƒ‰íŠ¸ë¦¬
> >
> > ![ì´ì§„íƒìƒ‰íŠ¸ë¦¬](README_ì‚¬ì§„/ì´ì§„íƒìƒ‰íŠ¸ë¦¬.png)
> >
> > íŠ¸ë¦¬ êµ¬ì¡°ì¤‘ ê°€ì¥ ê°„ë‹¨í•œ í˜•íƒœ.
> >
> > ë¶€ëª¨ ë…¸ë“œë³´ë‹¤ ì™¼ìª½ ìì‹ ë…¸ë“œê°€ ì‘ë‹¤.
> >
> > ë¶€ëª¨ ë…¸ë“œë³´ë‹¤ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œê°€ í¬ë‹¤.
> >
> > â¡ **ì™¼ìª½ ìì‹ë…¸ë“œ < ë¶€ëª¨ë…¸ë“œ < ì˜¤ë¥¸ìª½ ìì‹ë…¸ë“œ**
>
> #### ğŸ’¡ ë°ì´í„° ë¹ ë¥´ê²Œ ì…ë ¥ë°›ê¸°
>
>  ``` python
>  import sys
>  # í•˜ë‚˜ì˜ ë¬¸ìì—´ ë°ì´í„° ì…ë ¥ë°›ê¸°
>  input_data = sys.stdin.readline().rstrip()
>  ```
>
> ë°ì´í„°ë¥¼ ì…ë ¥ë°›ì„ ë•Œ ë§ˆì§€ë§‰ `Enter` ë¥¼ ëˆ„ë¥´ë©´ì„œ ì¤„ë°”ê¿ˆ ê¸°í˜¸ê°€ ë“¤ì–´ê°€ê¸° ë•Œë¬¸ì— `rstrip`ì„ ê¼­ ë§ˆì§€ë§‰ì— ì‚¬ìš©í•´ì£¼ì



## DP ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°(ë™ì  í”„ë¡œê·¸ë˜ë°)

### ğŸ’¡ í•œë²ˆ ê³„ì‚° ë¬¸ì œëŠ” ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•ŠëŠ” ì•Œê³ ë¦¬ì¦˜ â¡ ë©”ëª¨ë¦¬ ì ˆì•½

> ëŒ€í‘œì ì¸ DP â¡ **í”¼ë³´ë‚˜ì¹˜ìˆ˜ì—´**
>
> **DPì‚¬ìš©ì¡°ê±´**
>
> 1. í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤
> 2. ì‘ì€ ë¬¸ì œì—ì„œ êµ¬í•œ ì •ë‹µì€ ê·¸ê²ƒì„ í¬í•¨í•œ í° ë¬¸ì œì—ì„œë„ ë™ì¼í•˜ë‹¤.
>
> #### ex í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ ì†ŒìŠ¤ì½”ë“œ
>
> ``` python
> def fibo(n):
>     if n == 1 or n == 2:
>         return 2
>     return fibo(n-1) + fibo(n-2)
> ```
>
> ëŠ˜ì–´ë‚˜ëŠ” ì¬ê·€í•¨ìˆ˜ë“¤ ì¤‘ì—ì„œ ë¶„ëª… ê°™ì€ ê°’ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ê°€ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì— í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì€ `n`ê°’ì´ ì»¤ì§ˆìˆ˜ë¡ ìƒê²¨ì•¼ í•˜ëŠ” ì•„ë˜ ì°¨ìˆ˜ í•­ë“¤ì´ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ëŠ˜ì–´ë‚œë‹¤. (ì‹œê°„ë³µì¡ë„: `O(2^N)`) â¡ ë©”ëª¨ì´ì œì´ì…˜ì„ í™œìš©í•´ í•œ ë²ˆ êµ¬í˜„í•œ ê°’ì„ ì €ì¥í•´ í•„ìš”í•  ë•Œ í˜¸ì¶œí•˜ë©´ ìˆ˜ê³ ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
>
> > **ë©”ëª¨ì´ì œì´ì…˜**
> >
> > í•œ ë²ˆ êµ¬í˜„í•œ ê°’ì„ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•˜ëŠ” ê²ƒ
>
> #### ë©”ëª¨ì´ì œì´ì…˜ì„ ì ìš©í•œ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ì½”ë“œ
>
> ```python
> d = [0]*100		# êµ¬í˜„í•œ ê°’ì„ ì €ì¥í•  ë©”ëª¨ì´ì œì´ì…˜ ë¦¬ìŠ¤íŠ¸
> def fibo(n):
>     if n == 1 || n == 2:
>         return 1
>     
>     if d[x] != 0:		# ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ê°’ì´ë¼ë©´ ë°”ë¡œ í˜¸ì¶œ
>         return d[x]
>     
>     d[x] = fibo(n-1) + fibo(n-2)
>     return d[x]
> ```
>
> ì´ë ‡ê²Œ êµ¬í˜„í•˜ë©´ ê°™ì€ ë¬¸ì œë„ ë©”ëª¨ë¦¬ê°€ íš¨ìš¸ì ìœ¼ë¡œ í•œ ë²ˆì”©ë§Œ ì‚¬ìš©ë˜ì–´ ì‹œê°„ë³µì¡ë„ê°€ `O(N)` ì´ë‹¤.
>
> í”¼ë³´ë‚˜ì¹˜ì²˜ëŸ¼ í° ë¬¸ì œë¥¼ í˜¸ì¶œí•˜ê¸° ìœ„í•´ ì‘ì€ ë¬¸ì œë“¤ì„ ê³„ì† í˜¸ì¶œí•˜ëŠ” ë°©ì‹ì„ í•˜í–¥ì‹ `Top down` ë°©ì‹ì´ë¼í•œë‹¤.
>
> ë°˜ëŒ€ë¡œ ì‘ì€ë¬¸ì œë¥¼ ê³„ì† í˜¸ì¶œí•´ í° ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ì‹ì€ ìƒí–¥ì‹ `Bottom up` ì´ë¼í•œë‹¤.
>
> #### Bottom up í”¼ë³´ë‚˜ì¹˜
>
> ``` python
> d = [0]*100
> d[1] = 1
> d[2] = 1
> for i in range(3, n+1):
>     d[i] = d[i-1] + d[i-2]
> print(d[n])
> ```
>
> 
>
> ì¶”ê°€ë¡œ ì¬ê·€í•¨ìˆ˜ëŠ” ê¹Šì´ê°€ 1000 ì´ìƒì¼ ì‹œ `recursion depth`  ê´€ë ¨ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤. ì´ëŸ° ê²½ìš°
>
> ``` python
> import sys
> sys.setrecursionlimit()
> ```
>
> ì„ í˜¸ì¶œí•´ ì™„í™”í•˜ì—¬ í’€ ìˆ˜ ìˆë‹¤.



## ìµœë‹¨ê²½ë¡œ

### ğŸ’¡ == ê¸¸ì°¾ê¸°ë¬¸ì œ

> ë‹¤ì–‘í•œ ì¢…ë¥˜ê°€ ë§ê³ , ìƒí™©ì—ë§ëŠ” ì•Œê³ ë¦¬ì¦˜ë“¤ì´ ì´ë¯¸ ë§ì´ ì •ë¦¬ë˜ì–´ìˆë‹¤.**ë‹¤ìµìŠ¤íŠ¸ë¼, í”Œë¡œì´ë“œ ì›Œì…œ, ë°¸ë§Œí¬ë“œ**
>
> > ### ë‹¤ìµìŠ¤íŠ¸ë¼
> >
> > #### ìŒì˜ë…¸ë“œê°€ ì—†ì„ ë•Œ, ì—¬ëŸ¬ê°œì˜ ë…¸ë“œ ì¤‘ íŠ¹ì • í•œ ë…¸ë“œì—ì„œ ì¶œë°œí•˜ì—¬ ë‹¤ë¥¸ë…¸ë“œë¡œ ê°€ëŠ” ê°ê°ì˜ ìµœë‹¨ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
> >
> > ì‹¤ì œ GPS ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì±„íƒë˜ê³  í•œë‹¤.
> >
> > ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ê²½ë¡œëŠ” ë§¤ë²ˆ ìµœì†Œë¹„ìš©ì„ íƒí•˜ê¸° ë•Œë¬¸ì— ê·¸ë¦¬ë””ë¡œ ë¶„ë¥˜ë˜ê¸°ë„ í•œë‹¤.
> >
> > 1. ì¶œë°œë…¸ë“œ ì„¤ì •
> >
> > 2. ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸” ì´ˆê¸°í™”
> >
> > 3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ ìµœë‹¨ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œì„ íƒ (ë°©ë¬¸ì²˜ë¦¬)
> >
> > 4. í•´ë‹¹ ë…¸ë“œë¥¼ ê±°ì³ ë‹¤ë¥¸ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš©ì„ ê³„ì‚°í•˜ì—¬ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ê°±ì‹ 
> >
> >    > í˜„ì¬ìœ„ì¹˜ì—ì„œ ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš©+í˜„ì¬ ë…¸ë“œê¹Œì§€ ëˆ„ì ë¹„ìš© ê³¼ ê¸°ì¡´ì— ì„¤ì •ëœ ë¹„ìš©ì„ ë¹„êµí•˜ì—¬ ìµœì†Œë¹„ìš©ì„ ì„ íƒ
> >
> > 5. `3` ê³¼ `4` ë¥¼ë°˜ë³µ
> >
> > **ë‹¤ìµìŠ¤íŠ¸ë¼ì˜ ë‘ê°€ì§€ êµ¬í˜„ ë°©ë²•**
> >
> > - êµ¬í˜„í•˜ê¸° ì‰½ì§€ë§Œ ëŠë¦¬ê²Œ ë™ì‘í•˜ëŠ” ì½”ë“œ
> > - êµ¬í˜„ì€ ì–´ë µì§€ë§Œ ë¹ ë¥´ê²Œ ë™ì‘í•˜ëŠ” ì½”ë“œ
> >
> > ``` python
> > import sys
> > input = sys.stdin.readline
> > 
> > INF = 1e9  # 10ì–µ, ê°ˆ ìˆ˜ ì—†ëŠ” ë…¸ë“œ ì¦‰ ë¬´í•œë¹„ìš©
> > N, M = map(int, input().split())    # ë…¸ë“œê°œìˆ˜, ê°„ì„ ê°œìˆ˜
> > start = int(input())                # ì‹œì‘ë…¸ë“œ
> > 
> > graph = [[] for _ in range(N+1)]
> > # ê° ë…¸ë“œì— ì—°ê²°ë˜ì–´ ìˆëŠ” ë…¸ë“œì— ëŒ€í•œ ì •ë³´ë¥¼ ë‹´ëŠ” ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°
> > 
> > visited = [False]*(N+1)
> > # ë°©ë¬¸í•œ ë…¸ë“œ ì²´í¬ë¥¼ ìœ„í•œ ë¦¬ìŠ¤íŠ¸
> > 
> > distance = [INF]*(N+1)
> > # ìµœë‹¨ê±°ë¦¬ í…Œì´ë¸” ì´ˆê¸°í™”
> > 
> > for _ in range(M):
> >     a, b, c = map(int,input().split())      # a ë…¸ë“œì—ì„œ b ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš© c
> >     graph[a].append((b,c))                  # ì—°ê²°ëœ ë…¸ë“œì™€ ë¹„ìš© ì…ë ¥
> > 
> > def smallest_cost():
> >     '''
> >     ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ , ê°€ì¥ ìµœë‹¨ ê±°ë¦¬ê°€ ì§§ì€ ë…¸ë“œì˜ ë²ˆí˜¸ë¥¼ ë°˜í™˜
> >     '''
> >     min_value = INF
> >     index = 0
> >     for i in range(1, N+1):
> >         if distance[i] < min_value and not visited[i]:
> >             min_value = distance[i]
> >             index = i
> >     return index
> > 
> > def dijstra(start):
> >     distance[start] = 0         # ì‹œì‘ë…¸ë“œ ê±°ë¦¬ 0
> >     visited[start] = True       # ì‹œì‘ë…¸ë“œ ë°©ë¬¸ì²˜ë¦¬
> >     for j in graph[start]:      # ì‹œì‘ë…¸ë“œê°€ ì—°ê²°ëœ ê³³ë“¤ì˜ ì •ë³´ j[0]: ì—°ê²°ë…¸ë“œ ë²ˆí˜¸ j[1]: ë¹„ìš©
> >         distance[j[0]] = j[1]   # ì—°ê²°ëœ ë…¸ë“œì˜ ê±°ë¦¬ ê°±ì‹ 
> > 
> >     for i in range(N-1):
> >         now = smallest_cost()   		   # =ë°©ë¬¸í•˜ì§€ ì•Šì€ ê³³ ì¤‘ ì œì¼ ì ì€ ë¹„ìš© ë“œëŠ”ë…¸ë“œ ë²ˆí˜¸
> >         visited[now] = True     		   # ë°©ë¬¸ì²˜ë¦¬
> >         for j in graph[now]:    		   # í˜„ì¬ë…¸ë“œê°€ ì—°ê²°ëœ ê³³ë“¤ì˜ ì •ë³´ j[0]: ì—°ê²°ë…¸ë“œ ë²ˆí˜¸ j[1]: ë¹„ìš©
> >             cost = distance[now] + j[1]     # í˜„ì¬ìœ„ì¹˜ê¹Œì§€ì˜ ë¹„ìš© + í˜„ì¬ìœ„ì¹˜ì—ì„œ ì—°ê²°ëœ ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš©
> >             if cost < distance[j[0]]:       # ì´ì „ì— ê³„ì‚°ëœ ìµœì†Œ ë¹„ìš©ë³´ë‹¤ costê°€ ì ë‹¤ë©´
> >                 distance[j[0]] = cost       # ê°±ì‹ 
> > 
> > dijstra(start)
> > ```
> >
> > **ì‹œê°„ë³µì¡ë„**: `O(V^2)` VëŠ” ì •ì ì˜ ê°œìˆ˜. ë‹¨ê³„ë§ˆë‹¤ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œë¥¼ ì„ íƒœê°›ê¸° ìœ„í•´ 1ì°¨ì› ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ì›ì†Œë¥¼ ìˆœì°¨íƒìƒ‰ í•˜ê¸° ë•Œë¬¸.
> >
> > 
> >
> > #### ê°œì„ ëœ ë‹¤ìµìŠ¤íŠ¸ë¼
> >
> > **í™(Heap)**ì„ ì‚¬ìš©í•˜ì—¬ ì‹œê°„ë³µì¡ë„ë¥¼ `O(ElogV)` ê¹Œì§€ ì¤„ì¼ ìˆ˜ ìˆë‹¤
> >
> > > **Heap**
> > >
> > > ìš°ì„ ìˆœìœ„ í(Priority Queue)ë¥¼ ê·œí˜„í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ìë£Œêµ¬ì¡°ì¤‘ í•˜ë‚˜.
> > >
> > > ìš°ì„ ìˆœìœ„ íëŠ” **ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ì€ ë°ì´í„°ë¥¼ ê°€ì¥ ë¨¼ì € ì œê±°í•˜ëŠ” í**
> > >
> > > |                   ìë£Œêµ¬ì¡° | ì¶”ì¶œë˜ëŠ” ë°ì´í„°             |
> > > | -------------------------: | :-------------------------- |
> > > |                 ìŠ¤íƒ Stack | ê°€ì¥ ë‚˜ì¤‘ì— ì‚½ì…ëœ ë°ì´í„°   |
> > > |                   í Queue | ê°€ì¥ ë¨¼ì € ì‚½ì…ëœ ë°ì´í„°     |
> > > | ìš°ì„ ìˆœìœ„ í Priority Queue | ê°€ì¥ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ë°ì´í„° |
> > >
> > > ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œ ìš°ì„ ìˆœìœ„ í ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì œê³µí•œë‹¤. ë”°ë¼ì„œ ì¼ë°˜ì ì¸ ì½”í…Œì—ì„œ ìš°ë¦¬ê°€ ì§ì ‘ í™ ìë£Œêµ¬ì¡°ë¶€í„° ì‘ì„±í•´ ìš°ì„ ìˆœìœ„ íë¥¼ êµ¬í˜„í•  ì¼ì€ ì—†ë‹¤.
> > >
> > > íŒŒì´ì¬ì—ì„œëŠ” ìš°ì„ ìˆœìœ„ íê°€ í•„ìš”í•  ë•Œ `Priority Queue` ë³´ë‹¤ëŠ” ì¼ë°˜ì ìœ¼ë¡œ `heapq`ê°€ ë” ë¹ ë¥´ê²Œ ë™ì‘í•˜ê¸° ë•Œë¬¸ì— ìˆ˜í–‰ì‹œê°„ì´ ì œí•œëœ ìƒí™©ì—ì„œ `heapq`ë¥¼ ì‚¬ìš©í•˜ëŠ”ê²ƒì„ ê¶Œì¥í•œë‹¤.
> > >
> > > ë³´í†µ ì •ìˆ˜í˜• ìë£Œí˜•ì˜ ë³€ìˆ˜ê°€ ìš°ì„ ìˆœìœ„ì˜ ê°’ì„ í‘œí˜„.
> > >
> > > - **ìµœì†Œí™(Min Heap)**: ê°’ì´ ê°€ì¥ ë‚®ì€ ë°ì´í„° ë¨¼ì € ì‚­ì œ
> > > - **ìµœëŒ€í™(Max Heap)**: ê°’ì´ ê°€ì¥ í° ë°ì´í„° ë¨¼ì € ì‚­ì œ
> > >
> > > ìµœì†Œí™ì„ ìµœëŒ€í™ ì²˜ëŸ¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ìµœì†Œí™ ì˜ ê°’ì„ ìŒìˆ˜ë¶€í˜¸(-)ë¥¼ ë„£ì–´ ì‚½ì…í•˜ì˜€ë‹¤ê°€ ì¶”ì¶œì‹œ í•œ ë²ˆ ë” ë¶™ì—¬ì„œ ì–‘ìˆ˜ë¡œ ë°”ê¿” ì‚¬ìš©í•˜ëŠ” ê¸°ìˆ ë„ ìˆìŒ
> > >
> > > | ìš°ì„ ìˆœìœ„ í êµ¬í˜„ë°©ì‹ | ì‚½ì… ì‹œê°„ | ì‚­ì œ ì‹œê°„ |
> > > | -------------------- | --------- | --------- |
> > > | ë¦¬ìŠ¤íŠ¸               | O(1)      | O(N)      |
> > > | í™                   | O(logN)   | O(logN)   |
> >
> > 1. ì¶œë°œ ë…¸ë“œë¥¼ ì œì™¸í•œ ëª¨ë“  ë…¸ë“œ ë¬´í•œë¹„ìš© ì²˜ë¦¬
> > 2. ì¶œë°œë…¸ë“œê¹Œì§€ ë¹„ìš© 0 ê³¼ ì¶œë°œë…¸ë“œ ì •ë³´ë¥¼ (ê±°ë¦¬, ë…¸ë“œ) íŠœí”Œí˜•íƒœë¡œ ìµœì†Œ í™ì— ì‚½ì… ex (0, 1)
> > 3. í™ì—ì„œ í˜„ì¬ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ì¶”ì¶œ
> > 4. ì¶”ì¶œí•œ ë…¸ë“œì—ì„œ ê±°ë¦¬ê°€ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° êº¼ë‚´ ê°ˆìˆ˜ìˆëŠ” ë…¸ë“œì™€ ê±°ë¦¬ë¥¼ `2`ë²ˆê³¼ ê°™ì€ í˜•íƒœë¡œ ìµœì†Œí™ì— ì‚½ì…
> > 5. `3` ë²ˆê³¼ `4`ë²ˆ ë°˜ë³µ.
> > 6. ìµœì¢…ì ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ë…¸ë“œê°€ ë‹¤ ì‚­ì œë˜ê³ , ì´ë¯¸ ë°©ë¬¸í•œ íŠœí”Œì´ ìˆë‹¤ë©´ ë¬´ì‹œ(ì‚­ì œ)
> >
> > ```  python
> > import heapq
> > import sys
> > input = sys.stdin.readline
> > 
> > INF = 1e9  # 10ì–µ, ê°ˆ ìˆ˜ ì—†ëŠ” ë…¸ë“œ ì¦‰ ë¬´í•œë¹„ìš©
> > N, M = map(int, input().split())    # ë…¸ë“œê°œìˆ˜, ê°„ì„ ê°œìˆ˜
> > start = int(input())                # ì‹œì‘ë…¸ë“œ
> > 
> > graph = [[] for _ in range(N+1)]
> > # ê° ë…¸ë“œì— ì—°ê²°ë˜ì–´ ìˆëŠ” ë…¸ë“œì— ëŒ€í•œ ì •ë³´ë¥¼ ë‹´ëŠ” ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°
> > 
> > distance = [INF]*(N+1)
> > # ìµœë‹¨ê±°ë¦¬ í…Œì´ë¸” ì´ˆê¸°í™”
> > 
> > for _ in range(M):
> >     a, b, c = map(int,input().split())      # a ë…¸ë“œì—ì„œ b ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš© c
> >     graph[a].append((b,c))                  # ì—°ê²°ëœ ë…¸ë“œì™€ ë¹„ìš© ì…ë ¥
> > 
> > def dijstra(start):
> >     '''
> >     ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ , ê°€ì¥ ìµœë‹¨ ê±°ë¦¬ê°€ ì§§ì€ ë…¸ë“œì˜ ë²ˆí˜¸ë¥¼ ë°˜í™˜
> >     '''
> >     q = []
> >     heapq.heappush(q, (0, start))
> >     # ì‹œì‘ ë…¸ë“œë¡œ ê°€ëŠ” ê²½ë¡œëŠ” 0ìœ¼ë¡œ ì„¤ì • í›„ qì— ì‚½ì…
> >     distance[start] = 0
> >     while q:        # qê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ë°˜ë³µ
> >         dist, now = heapq.heappop(q)
> >         # ê°€ì¥ ìµœë‹¨ ê±°ë¦¬ê°€ ì§§ì€ ë…¸ë“œì— ëŒ€í•œ ì •ë³´ êº¼ë‚´ê¸°
> >         if distance[now] < dist:
> >             continue
> >         # ì²˜ë¦¬ëœ ì  ìˆëŠ” ë…¸ë“œëŠ” ë¬´ì‹œ
> >         for i in graph[now]:
> >             cost = dist + i[1]
> >             if cost < distance[i[0]]:
> >                 distance[i[0]] = cost
> >                 heapq.heappush(q,(cost, i[0]))
> >                 # í˜„ì¬ ë…¸ë“œë¥¼ ê±°ì³ì„œ, ë‹¤ë¥¸ ë…¸ë“œë¥¼ ì´ë™í•˜ëŠ” ê±°ë¦¬ê°€ ë” ì§§ì€ê²½ìš° ê°±ì‹ 
> > ```
> >
> > **ì‹œê°„ë³µì¡ë„**: `O(ElogV)`. ì¼ë°˜ ë‹¤ìµìŠ¤íŠ¸ë¼ì™€ ë‹¤ë¥´ê²Œ í•œë²ˆ ì²˜ë¦¬í•œ ë…¸ë“œëŠ” `continue`ë¡œ ì§€ë‚˜ê°„ë‹¤.ë”°ë¼ì„œ `while`ë°˜ë³µë¬¸ì€ ë…¸ë“œ ê°œìˆ˜ V ì´ìƒ ë°˜ë³µí•˜ì§€ ì•ŠëŠ”ë‹¤. Vë²ˆ ë°˜ë³µë  ë•Œë§ˆë‹¤ ê°ê° ìì‹ ê³¼ ì—°ê²°ëœ ëª¨ë“  ê°„ì„ ë“¤ì„ í™•ì¸í•œë‹¤.
> >
> > ë”°ë¼ì„œ í˜„ì¬ ìš°ì„ ìˆœìœ„íì—ì„œ êº¼ë‚¸ ë…¸ë“œì™€ ì—°ê²°ëœ ë‹¤ë¥¸ ë…¸ë“œë“¤ì„ í™•ì¸í•˜ëŠ” ì´ íšŸìˆ˜ëŠ” ìµœëŒ€ê°„ì„ ì˜ ê°œìˆ˜ ë§Œí¼ ì—°ì‚°ì´ ìˆ˜í–‰ ë  ìˆ˜ ìˆë‹¤.
> >
> > #### ì‹œê°„ë³µì¡ë„ ê³„ì‚°
> >
> > ì‚½ì…ì˜ ê²½ìš° í™ì€ `logN`ì´ ê±¸ë¦¬ê³  Eê°œì˜ ê°„ì„ ì„ ëª¨ë‘ ë„£ìœ¼ë‹ˆ `ElogE` ê°€ ëœë‹¤ ì´ë•Œ ì¤‘ë³µê°„ì„ ì€ í¬í•¨í•˜ì§€ ì•Šìœ¼ë‹ˆ EëŠ” í•­ìƒ V^2 ë³´ë‹¤ ì‘ë‹¤. ì™œëƒë©´ ëª¨ë“  ë…¸ë“œë¼ë¦¬ ì„œë¡œ ë‹¤ ì—°ê²°ë˜ì–´ ìˆë‹¤ê³  í•  ë•Œ ê°„ì„ ì˜ ê°œìˆ˜ë¥¼ ì•½ V^2ê°œë¡œ ë³¼ ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ `logE`ëŠ” `logV^2`ë³´ë‹¤ ì‘ê¸°ì— ì´ë•Œ `O(logE)`ëŠ” `Olog(V^2)`ê°€ ë˜ê³  `O(2logV)` ê°€ ë˜ì–´ ìµœì¢…ì ìœ¼ë¡œ ê°„ë‹¨íˆ `O(ElogV)` ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤. 
>
> 
>
> > ### í”Œë£¨ì´ë“œ ì›Œì…œ
> >
> > #### ëª¨ë“  ì§€ì ì—ì„œ ëª¨ë“  ë‹¤ë¥¸ ì§€ì  ê¹Œì§€ì˜ ìµœë‹¨ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
> >
> > ë‹¤ìµìŠ¤íŠ¸ë¼ì™€ ë‹¤ë¥¸ì 
> >
> > - ë‹¤ìµìŠ¤íŠ¸ë¼ëŠ” í•œ ì§€ì ì—ì„œ ëª¨ë“  ì§€ì ìœ¼ë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œ
> > - í”Œë£¨ì´ë“œ ì›Œì…œì€ ë°©ë¬¸ì—¬ë¶€ë¥¼ ë”°ì§€ì§€ ì•ŠìŒ
> > - í”Œë£¨ì´ë“œ ì›Œì…œì€ Nê°œì˜ ë…¸ë“œë¥¼ Në²ˆì— ë§ê²Œ ë‹¨ê³„ë¥¼ ë°˜ë³µí•˜ê³  ì í™”ì‹ì— ë§ê²Œ 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ë¥¼ ê°œì„ í•˜ê¸° ë•Œë¬¸ì— DP
> >
> > ë…¸ë“œì˜ ê°œìˆ˜ê°€ Nê°œì¼ ë•Œ, Në²ˆì˜ ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•´ í•˜ë‚˜ì˜ ë…¸ë“œë‹¹ `O(N^2)` ì—°ì‚°ì´ ì´ë¤„ì§€ê³  ê²°ê³¼ì ìœ¼ë¡œ ì‹œê°„ë³µì¡ë„ëŠ” **O(N^2)**
> >
> >  ``` python
> >  INF = int(1e9)
> >  
> >  # n, m = ë…¸ë“œê°œìˆ˜, ê°„ì„ ê°œìˆ˜
> >  n = int(input())
> >  m = int(input())
> >  
> >  # ì¸ë±ìŠ¤ ê°’ì„ ì‰½ê²Œ ìƒê°í•˜ê¸° ìœ„í•´ n+1 x n+1 ë°°ì—´, ëª¨ë“  ê°’ ë¬´í•œìœ¼ë¡œì´ˆê¸°í™”
> >  matrix = [[INF] * (n+1) for _ in range(n+1)]
> >  
> >  # ìê¸° ìì‹ ìœ¼ë¡œëŠ” 0ìœ¼ë¡œ ì¹˜í™˜
> >  for i in range(1, n+1):
> >      matrix[i][i] = 0
> >  
> >  # ê°„ì„  ì •ë³´ ê·¸ë˜í”„ì— ì…ë ¥
> >  for _ in range(m):
> >      a, b, c = map(int, input().split())
> >      matrix[a][b] = c
> >  
> >  # ì í™”ì‹ì— ë”°ë¼ í”Œë£¨ì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
> >  for k in range(1, n+1):
> >      for i in range(1, n+1):
> >          for j in range(1, n+1):
> >              matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j])
> >  
> >  # ê²°ê³¼ ì¶œë ¥
> >  for r in range(1, n+1):
> >      for c in range(1, n+1):
> >          if matrix[r][c] == INF:
> >              print('INFINITY', end=' ')
> >          else:
> >              print(matrix[r][c], end=' ')
> >      print()
> >  ```


# 알고리즘

> 알고리즘은 무조건 많이 풀어보고 다양한 유형들을 숙지하고 있는것이 최고의 방법!
>
> 코딩테스트는 어려운 문제는 없지만 내가 다양한 각도에서 문제를 해결하는 방법을 갖고 있는지 판단하는 척도
>
> > ### 파이썬 코딩테스트
> >
> > 대체로 코테에서 128~512MB로 메모리를 제한하는데 파이썬에서는 메모리제한이 걸리기 쉽다.
> >
> > | 데이터 개수 | 메모리 사용량 |
> > | ----------- | ------------- |
> > | 1,000       | 약 4KB        |
> > | 1,000,000   | 약 4MB        |
> > | 10,000,000  | 약 40MB       |
> >
> > 리스트크기가 1,000만 이상인 경우 메모리제한 이슈가 발생활 확률이 높으니 꼭 고려하자



## 그리디 (탐욕알고리즘)

### 💡 현재 상황에서 지금 당장 좋은 것만 고르는 방법. 현재 선택이 나중에 미칠영향은 고려하지 않는다.

> 일반적으로 암기가 필요없는 알고리즘이지만 나아가서 `플로이드 워셜`, `다익스트라`, '크루스칼' 등 특정 알고리즘을 미리 알고있어야 풀 수 있는 알고리즘도 있음. 따라서 많은 문제를 풀어보는 것이 가장 중요.
>
> 해당 문제를 풀기위한 최소한의 아이디어를 떠올려 반복적으로 당장 좋은것을 고르는 방법인지 검토해야함.



## 구현

### 💡현재 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정. 문법숙지 필수!  다양한 라이브러리 경험이 있으면 더 좋다!

> 풀이를 떠올리는 것은 쉽지만 코드로 옮기는 것이 어려운 문제. 보통 사소한 입력 조건등을 명시해 주고 문제의 길이가 긴 편.
>
>  #### 완전탐색: 모든 경우의 수를 다 계산하는 방법
>
>  #### 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 문제
>
> 2차원 배열에서 방향벡터를 사용하는 문제가 자주 출제됨



## DFS & BFS

### 💡그래프를 탐색하기위한 대표적인 두 알고리즘

> #### 자료구조
>
> 데이터를 표현하고 관리하고 처리하기 위한 구조. DFS BFS 알고리즘을 위해 설명이 필요한 두가지의 자료구조 **stack** 과 **큐**
>
> > #### stack
> >
> > 흔히 박스쌓기로 비유. 아래에서 부터 위로 쌓고, 치울 때는 위에서부터 치운다.
> >
> > **선입후출(First In Last Out) 또는 후입선출(Last In First Out)**
> >
> > **ex**
> >
> > 삽입(5) 삽입(2) 삽입(3) 삽입(7) 삭제() 삽입(1) 삽입(4) 삭제() ....
> >
> > 5  2  3  (7)  1  (4)
> >
> > 최종 남은 stack 5231
>
> > #### queue
> >
> > 대기줄로 비유. 먼저 들어온 것이 먼저 나간다.
> >
> > 1 2 3 4 5 순으로 들어왔다면 호출도 1 2 3 4 5
>
> 
>
> > **큐 예제: 삽입(5) 삽입(2) 삽입(3) 삽입(7) 삭제() 삽입(1) 삽입(4) 삭제()**
> >
> > ``` python
> > from collection import deque
> > 
> > queue = deque()
> > 
> > queue.append(5)
> > queue.append(2)
> > queue.append(3)
> > queue.append(7)
> > queue.popleft()
> > queue.append(1)
> > queue.append(4)
> > queue.popleft()
> > 
> > print(queue)  # 5 2 3 1
> > queue.reverse()	 # 역순으로 바꿈
> > print(queue)  # 1 3 2 5
> > ```
> >
> > `queue` 라이브러리는 `list`와 비슷하지만 보다 연산속도가 빨라 코딩테스트에서 유리하다! `collection` 모듈은 대부분 코테에서도 채택해서 안심하고 사용할 수 있다



### DFS

> 깊이 우선 탐색(Depth-First-Search)라고 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
>
> 1. 탐색 시작 노드를 스택에 삽입하고 방문처리
> 2. 스택의 최사단 노드에 인접하고 방문하지 않은 노드가 있으면 인접노드를 스택에 넣고 방문 처리. 방문하지 않은 인접노드가 없으면 스택 최상단 노드를 꺼냄
> 3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복
>
> 주로 재귀함수`recursive function` 이용
>
> #### 그래프
>
> 그래프는 노트`Node`와 간선`Edge`로 표현되며 노드는 정점`Vertex`로 불리기도 한다.
>
> 그래프는 크게 두가지 방식으로 표현
>
> - 인접 행렬(Adjanceney Matrix): 2차원 배열로 그래프 연결관계를 표현하는 방식. 연결되지 않은 곳은 0 또는 무한 비용으로 처리
>
>   ``` python
>   INF = 9999999 # 무한비용
>   
>   graph = [
>       [0, 7, 5],
>       [7, 0, INF],
>       [5, INF, 0]
>   ]
>   ```
>
>   이 그래프는 0번 정점이 1, 2번 노드에 각각 7, 5 비용으로 연결
>
>   1번 정점이 0번에 만 연결, 2번 정점이 0번에만 연결되어 있음.
>
> - 인접 리스트(Adjanceney List): 리스트로 그래프의 연결관계를 표현하는 방식
>
>   > ```python
>   > graph = [[(1,7),(2,5)], [(0,7)], [(0,5)]
>   > ```
>   >
>   > 인접 행렬과 같은 연결상태를 인접 리스트로 표현함
>
> #### DFS method
>
> ``` python
> def DFS(graph, v, visited):
>     visited[v] = 1
>     for i in graph[v]:
>         if not visited[i]:
>             DFS(graph, i, visited)
> ```



### BFS

> 너비 우선 탐색(Breadth-First-Search) 가까운 노드부터 탐색하는 알고리즘. 주로 `queue` 이용
>
> 1. 탐색 시작 노드를 큐에 삽입하고 방문처리
> 2. 큐에서 노드를 꺼내 인접 노드중에 방문하지 않은 노드를 모두 큐에 삽입
> 3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복
>
> #### BFS method
>
> ``` python
> from collection import deque
> 
> def BFS(graph, start, visited):
>     queue = deque([start])
>     visited[start] = 1
>     
>     while queue:
>         v = queue.popleft()
>         for i in graph[v]:
>             if not visited[i]:
>                 queue.append(i)
>                 visited[i] = 1
> ```

